---
title: "NonHumanVocalExchanges"
author: "Chris Cox"
date: "2025-12-04"
output: pdf_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
# Initialisation
p_load(rstan, 
       bayesplot, 
       ggplot2, 
       coda, 
       circular, 
       moveHMM, 
       tidyr, 
       dplyr, 
       patchwork, 
       CircStats,
       deSolve,
       rstan,
       cowplot)
```

# Data Simulation, Reactive Reset

```{r}
# ============================================================================
# REACTIVE RESET: Simple Inter-Call Interval Model
# ============================================================================
# Based on Greenfield (1994) inhibitory resetting with rebound
#
# Key mechanism:
# - Baseline ICI = T (natural period)
# - When hearing partner call → pacemaker resets
# - Next ICI shortened to: τ = rebound_ratio × T
# - This creates alternation through mutual inhibition + rapid rebound
# ============================================================================

simulate_reactive_reset <- function(
  duration = 100,
  T1 = 1.0,                    # Natural period individual 1
  T2 = 1.0,                   # Natural period individual 2
  rebound_ratio = 0.3,         # KEY PARAMETER: τ/T
  call_duration = 0.3,
  noise_sd = 0.05,
  duration_noise_sd = 0.2
) {
  
  time <- 0
  voc_times_1 <- numeric()
  voc_times_2 <- numeric()
  voc_durations_1 <- numeric()
  voc_durations_2 <- numeric()
  reset_1 <- logical()  # Track which calls involved resets
  reset_2 <- logical()
  
  # Schedule first calls
  next_call_1 <- runif(1, 0, T1)
  next_call_2 <- runif(1, T1*0.3, T1*0.7)  # Start offset
  
  was_reset_1 <- FALSE
  was_reset_2 <- FALSE
  
  while (time < duration) {
    
    if (next_call_1 < next_call_2) {
      # ============ Individual 1 calls ============
      time <- next_call_1
      if (time >= duration) break
      
      voc_times_1 <- c(voc_times_1, time)
      voc_durations_1 <- c(voc_durations_1, call_duration + rnorm(1, 0, duration_noise_sd))
      reset_1 <- c(reset_1, was_reset_1)
      
      # Check if Individual 2 needs to reset
      # They reset if they're "about to call" (within one call duration)
      if ((next_call_2 - time) < call_duration * 1.5) {
        # Individual 2 is RESET!
        # They must wait, then call with shortened ICI (rebound)
        ICI_2 <- rebound_ratio * T2 + rnorm(1, 0, noise_sd)
        next_call_2 <- time + call_duration + ICI_2
        was_reset_2 <- TRUE
      } else {
        was_reset_2 <- FALSE
      }
      
      # Individual 1 continues with their period (normal or rebound)
      if (was_reset_1) {
        # This call was after a reset, so use rebound ICI
        ICI_1 <- rebound_ratio * T1 + rnorm(1, 0, noise_sd)
      } else {
        # Normal ICI
        ICI_1 <- T1 + rnorm(1, 0, noise_sd)
      }
      next_call_1 <- time + ICI_1
      was_reset_1 <- FALSE  # Reset flag for next iteration
      
    } else {
      # ============ Individual 2 calls ============
      time <- next_call_2
      if (time >= duration) break
      
      voc_times_2 <- c(voc_times_2, time)
      voc_durations_2 <- c(voc_durations_2, call_duration + rnorm(1, 0, duration_noise_sd))
      reset_2 <- c(reset_2, was_reset_2)
      
      # Check if Individual 1 needs to reset
      if ((next_call_1 - time) < call_duration * 1.5) {
        ICI_1 <- rebound_ratio * T1 + rnorm(1, 0, noise_sd)
        next_call_1 <- time + call_duration + ICI_1
        was_reset_1 <- TRUE
      } else {
        was_reset_1 <- FALSE
      }
      
      # Individual 2 continues
      if (was_reset_2) {
        ICI_2 <- rebound_ratio * T2 + rnorm(1, 0, noise_sd)
      } else {
        ICI_2 <- T2 + rnorm(1, 0, noise_sd)
      }
      next_call_2 <- time + ICI_2
      was_reset_2 <- FALSE
    }
  }
  
  # Reconstruct phases for comparison (approximate)
  # This helps us visualize the "sawtooth" pattern of discrete resets
  dt <- 0.01
  times <- seq(0, duration, dt)
  phases1 <- numeric(length(times))
  phases2 <- numeric(length(times))
  
  # Simple phase reconstruction: linear increase, jump at resets
  voc_idx_1 <- 1
  voc_idx_2 <- 1
  
  for (i in 1:length(times)) {
    t <- times[i]
    
    # Phase 1
    if (voc_idx_1 <= length(voc_times_1) && t >= voc_times_1[voc_idx_1]) {
      phases1[i] <- 0  # Reset at vocalization
      voc_idx_1 <- voc_idx_1 + 1
    } else if (voc_idx_1 > 1) {
      # Linear increase based on last ICI
      time_since_last <- t - voc_times_1[voc_idx_1 - 1]
      period <- if (voc_idx_1 <= length(voc_times_1)) {
        voc_times_1[voc_idx_1] - voc_times_1[voc_idx_1 - 1]
      } else {
        T1
      }
      phases1[i] <- (time_since_last / period) * 2 * pi
    }
    
    # Phase 2
    if (voc_idx_2 <= length(voc_times_2) && t >= voc_times_2[voc_idx_2]) {
      phases2[i] <- 0
      voc_idx_2 <- voc_idx_2 + 1
    } else if (voc_idx_2 > 1) {
      time_since_last <- t - voc_times_2[voc_idx_2 - 1]
      period <- if (voc_idx_2 <= length(voc_times_2)) {
        voc_times_2[voc_idx_2] - voc_times_2[voc_idx_2 - 1]
      } else {
        T2
      }
      phases2[i] <- (time_since_last / period) * 2 * pi
    }
  }
  
  list(
    voc_times_1 = voc_times_1,
    voc_times_2 = voc_times_2,
    voc_durations_1 = voc_durations_1,
    voc_durations_2 = voc_durations_2,
    reset_1 = reset_1,
    reset_2 = reset_2,
    times = times,
    phases1 = phases1,
    phases2 = phases2,
    T1 = T1,
    T2 = T2,
    rebound_ratio = rebound_ratio
  )
}

```

# Data Simulation, Gradual Entrainment

```{r}
simulate_entrainment_mechanism <- function(
  duration = 100,
  freq1 = 1.0,
  freq2 = 1.0,
  coupling = -0.15,
  dt = 0.01,
  phase_noise_sd = 0.05,
  duration_noise_sd = 0.2,
  ici_noise_sd = 0.05  # NEW: Add ICI-level variability
) {
  
  times <- seq(0, duration, dt)
  n_steps <- length(times)
  
  phases1 <- numeric(n_steps)
  phases2 <- numeric(n_steps)
  phases1[1] <- 0
  phases2[1] <- pi * 0.8
  
  voc_times_1 <- numeric()
  voc_times_2 <- numeric()
  voc_durations_1 <- numeric()
  voc_durations_2 <- numeric()
  
  for (i in 2:n_steps) {
    # Kuramoto coupling WITH NOISE
    dphase1 <- 2*pi*freq1 + coupling * sin(phases2[i-1] - phases1[i-1]) + rnorm(1, 0, phase_noise_sd)
    dphase2 <- 2*pi*freq2 + coupling * sin(phases1[i-1] - phases2[i-1]) + rnorm(1, 0, phase_noise_sd)
    
    phases1[i] <- phases1[i-1] + dphase1 * dt
    phases2[i] <- phases2[i-1] + dphase2 * dt
    
    # Detect vocalizations - ADD NOISE TO TIMING
    if (phases1[i] >= 2*pi && phases1[i-1] < 2*pi) {
      voc_time <- times[i] + rnorm(1, 0, ici_noise_sd)  # Add timing jitter
      voc_times_1 <- c(voc_times_1, voc_time)
      voc_durations_1 <- c(voc_durations_1, rnorm(1, 0.3, duration_noise_sd))
      phases1[i] <- phases1[i] %% (2*pi)
    }
    
    if (phases2[i] >= 2*pi && phases2[i-1] < 2*pi) {
      voc_time <- times[i] + rnorm(1, 0, ici_noise_sd)  # Add timing jitter
      voc_times_2 <- c(voc_times_2, voc_time)
      voc_durations_2 <- c(voc_durations_2, rnorm(1, 0.3, duration_noise_sd))
      phases2[i] <- phases2[i] %% (2*pi)
    }
    
    phases1[i] <- phases1[i] %% (2*pi)
    phases2[i] <- phases2[i] %% (2*pi)
  }
  
  list(
    times = times,
    phases1 = phases1,
    phases2 = phases2,
    voc_times_1 = voc_times_1,
    voc_times_2 = voc_times_2,
    voc_durations_1 = voc_durations_1,
    voc_durations_2 = voc_durations_2,
    freq1 = freq1,
    freq2 = freq2,
    coupling = coupling,
    phase_noise_sd = phase_noise_sd,
    duration_noise = duration_noise_sd
  )
}

simulate_entrainment_mechanism <- function(
  duration = 100,
  freq1 = 1.0,
  freq2 = 1.0,
  coupling = -0.15,
  dt = 0.01,
  phase_noise_sd = 0.05,
  duration_noise_sd = 0.2,
  ici_noise_sd = 0.05
) {
  
  times <- seq(0, duration, dt)
  n_steps <- length(times)
  
  phases1 <- numeric(n_steps)
  phases2 <- numeric(n_steps)
  
  # START NEAR SYNCHRONY (both near 0)
  phases1[1] <- 0
  phases2[1] <- 0.2  # Small offset - almost in phase
  
  voc_times_1 <- numeric()
  voc_times_2 <- numeric()
  voc_durations_1 <- numeric()
  voc_durations_2 <- numeric()
  
  for (i in 2:n_steps) {
    # Kuramoto coupling WITH NOISE
    dphase1 <- 2*pi*freq1 + coupling * sin(phases2[i-1] - phases1[i-1]) + rnorm(1, 0, phase_noise_sd)
    dphase2 <- 2*pi*freq2 + coupling * sin(phases1[i-1] - phases2[i-1]) + rnorm(1, 0, phase_noise_sd)
    
    phases1[i] <- phases1[i-1] + dphase1 * dt
    phases2[i] <- phases2[i-1] + dphase2 * dt
    
    # Detect vocalizations - ADD NOISE TO TIMING
    if (phases1[i] >= 2*pi && phases1[i-1] < 2*pi) {
      voc_time <- times[i] + rnorm(1, 0, ici_noise_sd)
      voc_times_1 <- c(voc_times_1, voc_time)
      voc_durations_1 <- c(voc_durations_1, rnorm(1, 0.3, duration_noise_sd))
      phases1[i] <- phases1[i] %% (2*pi)
    }
    
    if (phases2[i] >= 2*pi && phases2[i-1] < 2*pi) {
      voc_time <- times[i] + rnorm(1, 0, ici_noise_sd)
      voc_times_2 <- c(voc_times_2, voc_time)
      voc_durations_2 <- c(voc_durations_2, rnorm(1, 0.3, duration_noise_sd))
      phases2[i] <- phases2[i] %% (2*pi)
    }
    
    phases1[i] <- phases1[i] %% (2*pi)
    phases2[i] <- phases2[i] %% (2*pi)
  }
  
  list(
    times = times,
    phases1 = phases1,
    phases2 = phases2,
    voc_times_1 = voc_times_1,
    voc_times_2 = voc_times_2,
    voc_durations_1 = voc_durations_1,
    voc_durations_2 = voc_durations_2,
    freq1 = freq1,
    freq2 = freq2,
    coupling = coupling,
    phase_noise_sd = phase_noise_sd,
    duration_noise = duration_noise_sd
  )
}

```

# Convert to Vocalisations

```{r}
# ============================================================================
# HELPER FUNCTION (Match your create_voc_dataframe)
# ============================================================================

create_voc_dataframe <- function(sim_result, mechanism_name) {
  bind_rows(
    tibble(
      Mechanism = mechanism_name,
      Individual = "Individual 1",
      StartTime = sim_result$voc_times_1,
      Duration = sim_result$voc_durations_1,
      EndTime = StartTime + Duration
    ),
    tibble(
      Mechanism = mechanism_name,
      Individual = "Individual 2",
      StartTime = sim_result$voc_times_2,
      Duration = sim_result$voc_durations_2,
      EndTime = StartTime + Duration
    )
  )
}

reset_sim <- simulate_reactive_reset(
  duration = 400,
  T1 = 1.0,
  T2 = 1,
  rebound_ratio = 0.35,
  call_duration = 0.25,
  noise_sd = 0.2,
  duration_noise_sd = 0.05
)

osc_sim <- simulate_entrainment_mechanism(
  duration = 100,
  freq1 = 1.0,
  freq2 = 1.0,     # Different frequencies to see entrainment
  coupling = -0.06,
  phase_noise_sd = 0.02,
  duration_noise_sd = 0.2,
  ici_noise_sd = 0.09  # This adds realistic ICI variability
)

osc_sim2 <- simulate_entrainment_mechanism(
  duration = 100,
  freq1 = 1.0,
  freq2 = 1.0,     # Different frequencies to see entrainment
  coupling = 0.05,
  phase_noise_sd = 0.02,
  duration_noise_sd = 0.2,
  ici_noise_sd = 0.05  # This adds realistic ICI variability
)

# Create vocalization dataframes
vocs_reset <- create_voc_dataframe(reset_sim, "Reactive Reset")
vocs_entrainment <- create_voc_dataframe(osc_sim, "Entrainment")
vocs_synchrony <- create_voc_dataframe(osc_sim2, "Synchrony")

# Combine for comparison
all_vocs <- bind_rows(vocs_reset, 
                      vocs_entrainment, 
                      #vocs_synchrony
                      )
```

# Visualise

```{r}
# First, create the all_vocs dataframe from both simulations
all_vocs <- bind_rows(
  tibble(
    Mechanism = "Entrainment",
    Individual = "Individual 1",
    StartTime = osc_sim$voc_times_1,
    EndTime = osc_sim$voc_times_1 + osc_sim$voc_durations_1
  ),
  tibble(
    Mechanism = "Entrainment",
    Individual = "Individual 2",
    StartTime = osc_sim$voc_times_2,
    EndTime = osc_sim$voc_times_2 + osc_sim$voc_durations_2
  ),
  tibble(
    Mechanism = "Reactive Reset",
    Individual = "Individual 1",
    StartTime = reset_sim$voc_times_1,
    EndTime = reset_sim$voc_times_1 + reset_sim$voc_durations_1
  ),
  tibble(
    Mechanism = "Reactive Reset",
    Individual = "Individual 2",
    StartTime = reset_sim$voc_times_2,
    EndTime = reset_sim$voc_times_2 + reset_sim$voc_durations_2
  )
)

# Panel A: Vocalization timing
panel_a <- all_vocs %>%
  filter(StartTime < 20) %>%
  mutate(
    y_pos = ifelse(Individual == "Individual 1", 0.6, 0.4),
    Mechanism = factor(Mechanism, levels = c("Entrainment", "Reactive Reset"))
  ) %>%
  ggplot() +
  geom_rect(aes(xmin = StartTime, xmax = EndTime,
                ymin = y_pos - 0.05, ymax = y_pos + 0.05,
                fill = Individual), alpha = 0.7, color = "black", linewidth = 0.3) +
  facet_wrap(~Mechanism, ncol = 1) +
  scale_fill_manual(values = c("Individual 1" = "#E69F00", "Individual 2" = "#56B4E9")) +
  scale_y_continuous(breaks = c(0.4, 0.6), labels = c("Individual 2", "Individual 1")) +
  scale_x_continuous(breaks = seq(0, 20, 5), limits = c(0, 20)) +
  labs(x = "Time (seconds)", y = "",
       title = "A) Both Mechanisms Produce Alternation") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 20, face = "bold", color = "black"), 
    axis.text.x = element_text(size = 15, color = "black"),
    axis.title.x = element_text(size = 15, color = "black"),
    axis.text.y = element_text(size = 15, color = "black"),
    axis.title.y = element_text(size = 15, color = "black"),
    legend.position = "none",
    strip.background = element_rect(color = "white", fill = "white", linewidth = 1.5, linetype = "solid"),
    strip.text.x = element_text(size = 15, color = "black", face = "bold"),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(),
    panel.grid.minor.x = element_blank(),
    panel.border = element_blank(),
    panel.spacing = unit(1.5, "cm"),
    plot.margin = margin(t = 0.5, r = 0.5, b = 0.5, l = 0.5, unit = "cm")
  )

panel_a


# Panel B: Phase dynamics
phase_data <- bind_rows(
  tibble(
    Mechanism = "Reactive Reset",
    Time = reset_sim$times,
    Phase1 = reset_sim$phases1,
    Phase2 = reset_sim$phases2
  ) %>% filter(Time < 50),
  tibble(
    Mechanism = "Entrainment", 
    Time = osc_sim$times,
    Phase1 = osc_sim$phases1,
    Phase2 = osc_sim$phases2
  ) %>% filter(Time < 50)
) %>%
  mutate(
    PhaseDiff = (Phase1 - Phase2) %% (2*pi),
    Mechanism = factor(Mechanism, levels = c("Entrainment", "Reactive Reset"))
  )

panel_b <- phase_data %>%
  ggplot(aes(x = Time, y = PhaseDiff, color = Mechanism)) +
  geom_hline(yintercept = pi, linetype = "dashed", color = "gray40", linewidth = 0.8, alpha = 0.7) +
  geom_line(linewidth = 1.2) +
  scale_y_continuous(
    breaks = c(0, pi/2, pi, 3*pi/2, 2 * pi), 
    labels = c('0', 'π/2', 'π', '3π/2', '2π'),
    limits = c(0, 2*pi)
  ) +
  facet_wrap(~Mechanism, ncol = 1) +
  scale_color_manual(values = c("Reactive Reset" = "#E69F00", 
                                "Entrainment" = "#56B4E9")) +
  labs(x = "Time (seconds)", 
       y = "Phase Difference",
       title = "B) Phase Dynamics Reveal Distinct Mechanisms") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 20, face = "bold", color = "black"), 
    axis.text.x = element_text(size = 15, color = "black"),
    axis.title.x = element_text(size = 15, color = "black"),
    axis.text.y = element_text(size = 15, color = "black"),
    axis.title.y = element_text(size = 15, color = "black"),
    legend.position = "none",
    strip.background = element_rect(color = "white", fill = "white", linewidth = 1.5, linetype = "solid"),
    strip.text.x = element_text(size = 15, color = "black", face = "bold"),
    panel.grid.minor.y = element_blank(),
    panel.grid.minor.x = element_blank(),
    panel.border = element_blank(),
    panel.spacing = unit(1.5, "cm"),
    plot.margin = margin(t = 0.5, r = 0.5, b = 0.5, l = 0.5, unit = "cm")
  )

panel_b

# Panel C: Polar plot of phase differences (simpler and cleaner!)
# Sample the phase difference at regular intervals
polar_data <- bind_rows(
  tibble(
    Mechanism = "Reactive Reset",
    Time = reset_sim$times,
    Phase1 = reset_sim$phases1,
    Phase2 = reset_sim$phases2
  ),
  tibble(
    Mechanism = "Entrainment", 
    Time = osc_sim$times,
    Phase1 = osc_sim$phases1,
    Phase2 = osc_sim$phases2
  )
) %>%
  mutate(
    PhaseDiff = (Phase1 - Phase2) %% (2*pi),
    Mechanism = factor(Mechanism, levels = c("Entrainment", "Reactive Reset"))
  ) %>%
  # Sample every 100th point to avoid overplotting
  filter(row_number() %% 100 == 0)

panel_c <- polar_data %>%
  ggplot(aes(x = PhaseDiff, fill = Mechanism)) +
  geom_histogram(bins = 30, color = "black", linewidth = 0.3, alpha = 0.8) +
  coord_polar(start = 0, direction = 1) +
  scale_x_continuous(
    breaks = seq(0, 2*pi, length.out = 9)[-9],
    labels = c("0", "π/4", "π/2", "3π/4", "π", "5π/4", "3π/2", "7π/4"),
    limits = c(0, 2*pi)
  ) +
  scale_fill_manual(values = c("Reactive Reset" = "#E69F00", 
                               "Entrainment" = "#56B4E9")) +
  facet_wrap(~Mechanism, ncol = 2) +
  labs(title = "C) Phase Relationships") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 20, face = "bold", color = "black"),
    plot.subtitle = element_text(hjust = 0.5, size = 13, color = "black"),
    axis.text.x = element_text(size = 12, color = "black"),
    axis.text.y = element_blank(),
    axis.title = element_blank(),
    legend.position = "none",
    strip.background = element_rect(color = "white", fill = "white", linewidth = 1.5, linetype = "solid"),
    strip.text.x = element_text(size = 15, color = "black", face = "bold"),
    panel.grid.major = element_line(color = "gray80", linewidth = 0.5),
    panel.grid.minor = element_blank(),
    plot.margin = margin(t = 0.5, r = 0.5, b = 0.5, l = 0.5, unit = "cm")
  )

panel_c

# Panel D: ICI distributions showing bimodality
ici_data <- bind_rows(
  reset_df %>% mutate(Mechanism = "Reactive Reset"),
  osc_df %>% mutate(Mechanism = "Entrainment")
) %>%
  mutate(Mechanism = factor(Mechanism, levels = c("Entrainment", "Reactive Reset")))

panel_d <- ici_data %>%
  ggplot(aes(x = ici, fill = Mechanism)) +
  geom_histogram(aes(y = after_stat(density)), bins = 40, alpha = 0.7, 
                 color = "black", linewidth = 0.8) +
  geom_density(alpha = 0.3, linewidth = 1.2) +
  facet_wrap(~Mechanism, ncol = 1, scales = "free_y") +
  scale_fill_manual(values = c("Reactive Reset" = "#E69F00", 
                               "Entrainment" = "#56B4E9")) +
  scale_x_continuous(breaks = seq(0, 2, 0.5), limits = c(0, 2)) +
  labs(x = "Inter-Call Interval (seconds)", 
       y = "Density",
       title = "D) ICI Distributions: Bimodal vs. Unimodal") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 20, face = "bold", color = "black"), 
    axis.text.x = element_text(size = 15, color = "black"),
    axis.title.x = element_text(size = 15, color = "black"),
    axis.text.y = element_blank(),
    axis.title.y = element_text(size = 15, color = "black"),
    legend.position = "none",
    strip.background = element_rect(color = "white", fill = "white", linewidth = 1.5, linetype = "solid"),
    strip.text.x = element_text(size = 15, color = "black", face = "bold"),
    panel.grid.minor.y = element_blank(),
    panel.grid.minor.x = element_blank(),
    panel.border = element_blank(),
    panel.spacing = unit(1.5, "cm"),
    plot.margin = margin(t = 0.5, r = 0.5, b = 0.5, l = 0.5, unit = "cm")
  )

panel_d

full_panel_ab <- plot_grid(
          panel_a, NULL,
          panel_b, 
          nrow = 1,
          rel_widths = c(0.5, 0.05, 0.5))
          
full_panel_cd <- plot_grid(
          panel_c, NULL,
          panel_d, 
          nrow = 1,
          rel_widths = c(0.5, 0.05, 0.5))
          
full_panel <- plot_grid(
          full_panel_ab, NULL,
          full_panel_cd, 
          ncol = 1,
          rel_heights = c(0.5, 0.05, 0.5))

ggsave(plot = full_panel, file = 'full_panel.png', height = 12, width = 15)
```


```{r}

# ============================================================================
# CORRECTED PRC CALCULATION
# ============================================================================

calculate_prc_correct <- function(voc_times_self, voc_times_partner, baseline_T = 1.0) {
  
  prc_data <- tibble(
    stimulus_phase = numeric(),
    phase_shift = numeric()  # This is the key difference!
  )
  
  for (i in 2:(length(voc_times_self)-1)) {
    
    cycle_start <- voc_times_self[i]
    expected_next <- cycle_start + baseline_T  # When WOULD you call without stimulus
    actual_next <- voc_times_self[i+1]         # When you ACTUALLY called
    
    # Find partner calls between your current call and your next call
    partner_calls <- voc_times_partner[
      voc_times_partner > cycle_start & 
      voc_times_partner < actual_next
    ]
    
    if (length(partner_calls) > 0) {
      stimulus_time <- partner_calls[1]
      
      # Stimulus phase: where in your cycle (0-360°)
      stimulus_phase <- ((stimulus_time - cycle_start) / baseline_T) * 360
      
      # Phase shift: difference between expected and actual
      # Negative = advanced (called earlier), Positive = delayed (called later)
      shift_time <- actual_next - expected_next
      phase_shift <- (shift_time / baseline_T) * 360
      
      # Keep stimulus phase in -180 to 360 range
      if (stimulus_phase > 360) stimulus_phase <- stimulus_phase - 360
      
      prc_data <- prc_data %>% add_row(
        stimulus_phase = stimulus_phase,
        phase_shift = phase_shift
      )
    }
  }
  
  prc_data
}

# Calculate corrected PRCs
prc_reset_corrected <- bind_rows(
  calculate_prc_correct(reset_sim$voc_times_1, reset_sim$voc_times_2, 1.0),
  calculate_prc_correct(reset_sim$voc_times_2, reset_sim$voc_times_1, 1.0)
) %>% mutate(Mechanism = "Reactive Reset")

prc_osc_corrected <- bind_rows(
  calculate_prc_correct(osc_sim$voc_times_1, osc_sim$voc_times_2, 1.0),
  calculate_prc_correct(osc_sim$voc_times_2, osc_sim$voc_times_1, 1.0)
) %>% mutate(Mechanism = "Entrainment")

prc_corrected <- bind_rows(prc_reset_corrected, prc_osc_corrected) %>%
  mutate(Mechanism = factor(Mechanism, levels = c("Entrainment", "Reactive Reset")))

# Plot: Phase SHIFT vs Stimulus Phase
panel_c <- prc_corrected %>%
  filter(stimulus_phase >= 0 & stimulus_phase <= 360) %>%
  ggplot(aes(x = stimulus_phase, y = phase_shift)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray40", linewidth = 0.8) +
  geom_point(aes(color = Mechanism), size = 2, alpha = 0.8) +
  geom_smooth(aes(color = Mechanism, fill = Mechanism), method = "lm", formula = y ~ x, se = F, alpha = 0.8, linewidth = 1.5) +
  scale_color_manual(values = c("Reactive Reset" = "#E69F00", 
                                "Entrainment" = "#56B4E9")) +
  scale_fill_manual(values = c("Reactive Reset" = "#E69F00", 
                               "Entrainment" = "#56B4E9")) +
  scale_x_continuous(breaks = seq(0, 360, 90)) +
  scale_y_continuous(breaks = seq(-180, 360, 45), limits = c(-200, 400)) +
  #facet_wrap(~Mechanism, ncol = 2) +
  labs(x = "Stimulus Phase (°)", 
       y = "Phase Shift (°)\n(- = advance, + = delay)",
       title = "C) Phase Response Curves",
       #subtitle = "How partner's call timing shifts your response"
       ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 20, face = "bold", color = "black"),
    plot.subtitle = element_text(hjust = 0.5, size = 13, color = "black"),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 15, color = "black"),
    axis.title.y = element_text(size = 13, color = "black"),
    legend.position = c(0.9, 0.2),
    legend.title = element_blank(),
    legend.key.size = unit(1, "lines"),
    legend.text = element_text(size = 15),
    legend.background = element_rect(fill = "transparent", color = NA),
    legend.key = element_rect(fill = "transparent", color = NA),
    strip.background = element_rect(color = "white", fill = "white", linewidth = 1.5),
    strip.text.x = element_text(size = 15, color = "black", face = "bold"),
    panel.grid.minor = element_blank(),
    plot.margin = margin(t = 0.5, r = 0.5, b = 0.5, l = 0.5, unit = "cm")
  )

panel_c

```


